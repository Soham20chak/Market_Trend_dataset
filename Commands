cd home
cd ubh01
cd hadoop-2.7.1
cd sbin
./start-dfs.sh
./start-yarn.sh
jps
hadoop fs -mkdir -p /home/ubh01/ecommercedata
hadoop fs -put /home/ubh01/Downloads/OnlineRetail.csv /home/ubh01/ecommercedata
hadoop fs -mkdir -p /home/ubh01/customerdata
hadoop fs -put /home/ubh01/Downloads/Customers.csv /home/ubh01/customerdata

hive
hive
use default;
create table online_market(invoice_no string,stock_code string,item string,quantity int,invoice_date string,unit_price float,cust_id int,country string) row format delimited fields terminated by ',' stored as textfile location '/home/ubh01/ecommercedata/';

partitioning :
static -
create table static_partition_table(invoice_no string,stock_code string,cust_id int,item string,quantity int,invoice_date string,unit_price float) partitioned by (country string);

insert into table static_partition_table partition(country='France') select invoice_no,stock_code,item,quantity,invoice_date,unit_price,cust_id from online_market where country='France';
insert into table static_partition_table partition(country='Netherlands') select invoice_no,stock_code,item,quantity,invoice_date,unit_price,cust_id from online_market where country='Netherlands';
insert into table static_partition_table partition(country='Australia') select invoice_no,stock_code,item,quantity,invoice_date,unit_price,cust_id from online_market where country='Australia';
select * from static_partition_table;

dynamic -
hive> set hive.exec.dynamic.partition.mode=nonstrict;
hive> create table dynamic_partition_table(invoice_no string,stock_code string,citem string,quantity int,invoice_date string,unit_price float,ust_id int) partitioned by (country string);

insert into table dynamic_partition_table partition(country) select invoice_no,stock_code,item,quantity,invoice_date,unit_price,cust_id,country from online_market ;

-- Query total sales revenue by country
SELECT country, SUM(quantity * unit_price) AS total_sales_revenue
FROM dynamic_partition_table
GROUP BY country;

/* Query top selling items in a specific country */
SELECT country, item, SUM(quantity) AS total_quantity_sold
FROM dynamic_partition_table
WHERE country = 'France'
GROUP BY country, item
ORDER BY total_quantity_sold DESC limit 10;

/* Monthly Sales Trend by Country */
SELECT country,  case 
     when substring(invoice_date,1,2)='1/' then 'January'
     when substring(invoice_date,1,2)='2/' then 'February'
     when substring(invoice_date,1,2)='3/' then 'March'
 when substring(invoice_date,1,2)='4/' then 'April'
     when substring(invoice_date,1,2)='5/' then 'May'
     when substring(invoice_date,1,2)='6/' then 'June'
     when substring(invoice_date,1,2)='7/' then 'July'
     when substring(invoice_date,1,2)='8/' then 'August'
    when substring(invoice_date,1,2)='10' then 'October'
    when substring(invoice_date,1,2)='9/' then 'September'
    when substring(invoice_date,1,2)='11' then 'November'
    when substring(invoice_date,1,2)='12' then 'December'
     end as Month,SUM(quantity * unit_price) AS monthly_sales
FROM dynamic_partition_table where country='France'
GROUP BY country, substring(invoice_date,1,2) order by monthly_sales desc;


//////-- Query sales trends over time for a specific country
SELECT country, substring(invoice_date,1,2) AS month, SUM(quantity) AS total_quantity_sold
FROM dynamic_partition_table
WHERE country = 'Netherlands'
GROUP BY country, substring(invoice_date,1,2)
ORDER BY substring(invoice_date,1,2);/////

/* customer distribution by country */
SELECT country, COUNT(DISTINCT cust_id) AS num_customers
FROM dynamic_partition_table
GROUP BY country;

hive>  set hive.log.explain.output=true;
hive> set hive.exec.reducers.bytes.per.reducer=256000000;
select count(*) from online_market where country='France';
hive> select count(*) from dynamic_partition_table where country='France';


bucketing - 
create table bucketing_table(invoice_no int,stock_code string,item string,quantity int,invoice_date date,unit_price float,cust_id int,country string) clustered by (unit_price) into 15 buckets stored as textfile;

insert into bucketing_table select * from online_market;

--no of items whose price is more than 100
SELECT count(*)
FROM bucketing_table
WHERE unit_price >= 100;

create table bucketing_table_by_customer(invoice_no int,stock_code string,item string,quantity int,invoice_date date,unit_price float,cust_id int,country string) clustered by (cust_id) into 10 buckets stored as textfile;

create table customer(cust_id int,name STRING,email STRING,phone STRING) row format delimited fields terminated by ',' stored as textfile location '/home/ubh01/customerdata/';

CREATE TABLE customer_info (
    cust_id INT,
    name STRING,
    email STRING,
    phone STRING,
    PRIMARY KEY (cust_id)
)
CLUSTERED BY (cust_id) INTO 10 BUCKETS
STORED AS TEXTFILE;

insert into customer_info select * from customer;

-- Join operation between bucketing_table_by_customer and customer_info
SELECT b.*, c.name, c.email
FROM bucketing_table b
JOIN customer_info c
ON b.cust_id = c.cust_id;

EXPLAIN SELECT s.*, c.name, c.email
FROM sales s
JOIN customers c
ON s.cust_id = c.cust_id;

Partitioning with bucketing :-
CREATE TABLE ecommerce_partitioned_bucketed (
    invoice_no STRING,
    stockcode STRING,
    item STRING,
    quantity INT,
    invoice_date STRING,
    unit_price FLOAT,
    customer_id STRING
)
PARTITIONED BY (country STRING)
CLUSTERED BY (unit_price) INTO 15 BUCKETS;

INSERT OVERWRITE TABLE ecommerce_partitioned_bucketed
PARTITION (country)
SELECT invoice_no, stock_code, item, quantity, invoice_date, unit_price, cust_id, country
FROM online_market;

aggregating using country and unit_price buckets

EXPLAIN EXTENDED SELECT * FROM ecommerce_partitioned_bucketed WHERE country = 'Australia';

--compare countries by expensive items they are buying
SELECT country, count(*) AS no_of_expensive
FROM ecommerce_partitioned_bucketed where unit_price>100 and country in ('France','Netherlands','United Kingdom')
group by country order by no_of_expensive;


Queries - 
Sales Analysis - 

-- Total sales revenue
SELECT SUM(quantity * unit_price) AS total_sales_revenue FROM online_market;

-- Top selling items
SELECT item, SUM(quantity) AS total_quantity_sold FROM online_market GROUP BY item ORDER BY total_quantity_sold DESC limit 10;

Inventory analysis -
-- Inventory turnover rate
SELECT SUM(quantity) / COUNT(DISTINCT invoice_no) AS inventory_turnover_rate FROM online_market;

Customer analysis -
-- Customer segmentation based on purchasing behavior
SELECT cust_id, SUM(quantity) AS total_quantity_purchased
FROM online_market
GROUP BY cust_id limit 20;

-- Customer churn analysis
SELECT cust_id, COUNT(DISTINCT invoice_no) AS total_invoices
FROM online_market where cust_id is not null
GROUP BY cust_id limit 20;

Forecasting and Predictive Analytics:
-- Sales forecasting
SELECT substring(invoice_date,1,2), SUM(quantity) AS total_quantity_sold FROM online_market group by substring(invoice_date,1,2);



select sum(quantity*unit_price) , 
    case 
    when substring(invoice_date,1,2)='1/' then 'January'
    when substring(invoice_date,1,2)='2/' then 'February'
    when substring(invoice_date,1,2)='3/' then 'March'
    when substring(invoice_date,1,2)='4/' then 'April'
    when substring(invoice_date,1,2)='5/' then 'May'
    when substring(invoice_date,1,2)='6/' then 'June'
    when substring(invoice_date,1,2)='7/' then 'July'
    when substring(invoice_date,1,2)='8/' then 'August'
    when substring(invoice_date,1,2)='10' then 'October'
    when substring(invoice_date,1,2)='9/' then 'September'
    when substring(invoice_date,1,2)='11' then 'November'
    when substring(invoice_date,1,2)='12' then 'December'
    end as Month from online_market group by substring(invoice_date,1,2); 



